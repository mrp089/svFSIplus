diff --git a/Code/Source/svFSI/eq_assem.cpp b/Code/Source/svFSI/eq_assem.cpp
index c7d45f1..f61bb4a 100644
--- a/Code/Source/svFSI/eq_assem.cpp
+++ b/Code/Source/svFSI/eq_assem.cpp
@@ -49,6 +49,7 @@
 #include "stokes.h"
 #include "sv_struct.h"
 #include "ustruct.h"
+#include "vtk_xml.h"
 
 #include <math.h>
 
@@ -324,7 +325,7 @@ void b_neu_folw_p(ComMod& com_mod, const faceType& lFa, const Vector<double>& hg
 ///
 /// Ag(tDof,tnNo), Yg(tDof,tnNo), Dg(tDof,tnNo)
 //
-void global_eq_assem(ComMod& com_mod, CepMod& cep_mod, const mshType& lM, const Array<double>& Ag, const Array<double>& Yg, const Array<double>& Dg)
+void global_eq_assem(ComMod& com_mod, CepMod& cep_mod, CmMod& cm_mod, const mshType& lM, const Array<double>& Ag, const Array<double>& Yg, const Array<double>& Dg)
 {
   #define n_debug_global_eq_assem
   #ifdef debug_global_eq_assem
@@ -363,7 +364,8 @@ void global_eq_assem(ComMod& com_mod, CepMod& cep_mod, const mshType& lM, const
     break;
 
     case EquationType::phys_struct:
-      struct_ns::construct_dsolid(com_mod, cep_mod, lM, Ag, Yg, Dg);
+      // struct_ns::construct_dsolid(com_mod, cep_mod, lM, Ag, Yg, Dg);
+      struct_ns::construct_gr(com_mod, cep_mod, lM, Ag, Yg, Dg);
     break;
 
     case EquationType::phys_ustruct:
diff --git a/Code/Source/svFSI/eq_assem.h b/Code/Source/svFSI/eq_assem.h
index c303877..f82fff7 100644
--- a/Code/Source/svFSI/eq_assem.h
+++ b/Code/Source/svFSI/eq_assem.h
@@ -41,7 +41,7 @@ void b_assem_neu_bc(ComMod& com_mod, const faceType& lFa, const Vector<double>&
 
 void b_neu_folw_p(ComMod& com_mod, const faceType& lFa, const Vector<double>& hg, const Array<double>& Dg);
 
-void global_eq_assem(ComMod& com_mod, CepMod& cep_mod, const mshType& lM, const Array<double>& Ag, const Array<double>& Yg, const Array<double>& Dg);
+void global_eq_assem(ComMod& com_mod, CepMod& cep_mod, CmMod& cm_mod, const mshType& lM, const Array<double>& Ag, const Array<double>& Yg, const Array<double>& Dg);
 
 };
 
diff --git a/Code/Source/svFSI/gr_equilibrated.cpp b/Code/Source/svFSI/gr_equilibrated.cpp
index 67f91fa..66ce370 100644
--- a/Code/Source/svFSI/gr_equilibrated.cpp
+++ b/Code/Source/svFSI/gr_equilibrated.cpp
@@ -89,7 +89,7 @@ void stress_tangent_(const Array<double>& Fe, const double time, const Vector<do
 	const int n_t_pre = 1;
 
 	// number of time steps total
-	const int n_t_end = 11;
+	const int n_t_end = 101;
 
 	const double pretime = n_t_pre * dt;
 	const double endtime = n_t_end * dt;							// 11.0 | 31.0-32.0 (TEVG)
diff --git a/Code/Source/svFSI/lhsa.cpp b/Code/Source/svFSI/lhsa.cpp
index c6ac43b..8ed52b8 100644
--- a/Code/Source/svFSI/lhsa.cpp
+++ b/Code/Source/svFSI/lhsa.cpp
@@ -96,6 +96,9 @@ void add_col(const int tnNo, const int row, const int col, int& mnnzeic, Array<i
 //
 void do_assem(ComMod& com_mod, const int d, const Vector<int>& eqN, const Array3<double>& lK, const Array<double>& lR)
 {
+  // do_assem_residual(com_mod, d, eqN, lR);
+  // do_assem_tangent(com_mod, d, eqN, lK);
+
   auto& R = com_mod.R;
   auto& Val = com_mod.Val;
   const auto& rowPtr = com_mod.rowPtr;
@@ -137,6 +140,67 @@ void do_assem(ComMod& com_mod, const int d, const Vector<int>& eqN, const Array3
   }
 }
 
+
+void do_assem_residual(ComMod &com_mod, const int d, const Vector<int> &eqN,
+                       const Array<double> &lR)
+{
+  auto& R = com_mod.R;
+  auto& Val = com_mod.Val;
+  const auto& rowPtr = com_mod.rowPtr;
+  const auto& colPtr = com_mod.colPtr;
+
+  for (int a = 0; a < d; a++) {
+    int rowN = eqN(a);
+    if (rowN == -1) {
+      continue;
+    }
+    for (int i = 0; i < R.nrows(); i++) {
+      R(i,rowN) = R(i,rowN) + lR(i,a);
+    }
+  }
+}
+
+
+void do_assem_tangent(ComMod &com_mod, const int d, const Vector<int> &eqN,
+                      const Array3<double> &lK)
+{
+  auto& R = com_mod.R;
+  auto& Val = com_mod.Val;
+  const auto& rowPtr = com_mod.rowPtr;
+  const auto& colPtr = com_mod.colPtr;
+
+  for (int a = 0; a < d; a++) {
+    int rowN = eqN(a);
+    if (rowN == -1) {
+      continue;
+    }
+    for (int b = 0; b < d; b++) {
+      int colN = eqN(b);
+      if (colN == -1) {
+        continue;
+      }
+
+      int left = rowPtr(rowN);
+      int right = rowPtr(rowN+1);
+      int ptr = (right + left) / 2;
+
+      while (colN != colPtr(ptr)) {
+        if (colN > colPtr(ptr)) { 
+          left  = ptr;
+        } else { 
+          right = ptr;
+        }
+        ptr = (right + left) / 2;
+      }
+
+      for (int i = 0; i < Val.nrows(); i++) {
+        Val(i,ptr) = Val(i,ptr) + lK(i,a,b);
+      }
+    }
+  }
+}
+
+
 //------
 // lhsa
 //------
diff --git a/Code/Source/svFSI/lhsa.h b/Code/Source/svFSI/lhsa.h
index dc1c210..d4722ec 100644
--- a/Code/Source/svFSI/lhsa.h
+++ b/Code/Source/svFSI/lhsa.h
@@ -41,6 +41,12 @@ namespace lhsa_ns {
 
   void do_assem(ComMod& com_mod, const int d, const Vector<int>& eqN, const Array3<double>& lK, const Array<double>& lR);
 
+  void do_assem_residual(ComMod &com_mod, const int d, const Vector<int> &eqN,
+                         const Array<double> &lR);
+
+  void do_assem_tangent(ComMod &com_mod, const int d, const Vector<int> &eqN,
+                        const Array3<double> &lK);
+
   void lhsa(Simulation* simulation, int& nnz);
 
   void resiz(const int tnNo, int& mnnzeic, Array<int>& uInd);
diff --git a/Code/Source/svFSI/main.cpp b/Code/Source/svFSI/main.cpp
index 5fc3712..d4e5d09 100644
--- a/Code/Source/svFSI/main.cpp
+++ b/Code/Source/svFSI/main.cpp
@@ -326,7 +326,7 @@ void iterate_solution(Simulation* simulation)
       #endif
 
       for (int iM = 0; iM < com_mod.nMsh; iM++) {
-        eq_assem::global_eq_assem(com_mod, cep_mod, com_mod.msh[iM], Ag, Yg, Dg);
+        eq_assem::global_eq_assem(com_mod, cep_mod, cm_mod, com_mod.msh[iM], Ag, Yg, Dg);
       }
 
       com_mod.Val.write("Val_as"+ istr);
@@ -481,11 +481,6 @@ void iterate_solution(Simulation* simulation)
       pic::picc(simulation);
       com_mod.Yn.write("Yn_picc"+ istr);
 
-      // Add smoothing to growth and remodeling parameters
-      if (com_mod.grEq) {
-        vtk_xml::smooth_output(simulation);
-      }
-
       // Writing out the time passed, residual, and etc.
       if (std::count_if(com_mod.eq.begin(),com_mod.eq.end(),[](eqType& eq){return eq.ok;}) == com_mod.eq.size()) { 
         #ifdef debug_iterate_solution
diff --git a/Code/Source/svFSI/sv_struct.cpp b/Code/Source/svFSI/sv_struct.cpp
index f903212..4b28724 100644
--- a/Code/Source/svFSI/sv_struct.cpp
+++ b/Code/Source/svFSI/sv_struct.cpp
@@ -44,6 +44,7 @@
 #include "mat_models_fixed.h"
 #include "nn.h"
 #include "utils.h"
+#include "vtk_xml.h"
 
 #ifdef WITH_TRILINOS
 #include "trilinos_linear_solver.h"
@@ -200,7 +201,92 @@ void b_struct_3d(const ComMod& com_mod, const int eNoN, const double w, const Ve
   }
 }
 
-void construct_dsolid(ComMod& com_mod, CepMod& cep_mod, const mshType& lM, const Array<double>& Ag, const Array<double>& Yg, const Array<double>& Dg, const bool assembly)
+
+void construct_gr(ComMod& com_mod, CepMod& cep_mod, CmMod& cm_mod, 
+             const mshType& lM, const Array<double>& Ag, 
+             const Array<double>& Yg, const Array<double>& Dg)
+{
+  // Get dimensions
+  const int eNoN = lM.eNoN;
+  const int dof = com_mod.dof;
+
+  // Initialize residual and tangent
+  Vector<int> ptr(eNoN);
+  Array<double> lR(dof, eNoN);
+  Array3<double> lK(dof * dof, eNoN, eNoN);
+
+  const eps = 1.0e-8;
+
+  bool central = true;
+  eval_gr(com_mod, cep_mod, cm_mod, lM, Ag, Yg, Dg, central);
+
+  for (int e = 0; e < lM.nEl; e++) {
+    for (int i = 0; i < dof; ++i) {
+      for (int a = 0; a < eNoN; ++a) {
+        central = false;
+        eval_gr(com_mod, cep_mod, cm_mod, lM, Ag, Yg, Dg, central, eps, a);
+      }
+    }
+  }
+
+}
+
+void eval_gr(ComMod& com_mod, CepMod& cep_mod, CmMod& cm_mod, 
+             const mshType& lM, const Array<double>& Ag, 
+             const Array<double>& Yg, const Array<double>& Dg,
+             const bool central, const double eps=0.0, const double a=0)
+{
+  using namespace consts;
+
+  // Get dimensions
+  const int eNoN = lM.eNoN;
+  const int dof = com_mod.dof;
+
+  // Initialize residual and tangent
+  Vector<int> ptr_dummy(eNoN);
+  Vector<int> ptr(eNoN);
+  Array<double> lR_dummy(dof, eNoN);
+  Array<double> lR(dof, eNoN);
+  Array3<double> lK_dummy(dof * dof, eNoN, eNoN);
+  Array3<double> lK(dof * dof, eNoN, eNoN);
+  ptr = 0;
+  lR = 0.0;
+  lK = 0.0;
+  ptr_dummy = 0;
+  lR_dummy = 0.0;
+  lK_dummy = 0.0;
+
+  // Loop over all elements of mesh
+  for (int e = 0; e < lM.nEl; e++) {
+    // Evaluate solid equations to update internal G&R variables 
+    // (without assembly)
+    eval_dsolid(e, com_mod, cep_mod, lM, Ag, Yg, Dg, 
+                ptr_dummy, lR_dummy, lK_dummy);
+  }
+
+  // Smooth internal G&R variables
+  // vtk_xml::smooth_output(com_mod, cm_mod);
+  
+  // Loop over all elements of mesh
+  for (int e = 0; e < lM.nEl; e++) {
+    // Reset
+    ptr = 0;
+    lR = 0.0;
+    lK = 0.0;
+
+    // Evaluate solid equations with smooth internal G&R variables
+    eval_dsolid(e, com_mod, cep_mod, lM, Ag, Yg, Dg, ptr, lR, lK_dummy);
+
+    // Assemble into global residual and tangent
+    // lhsa_ns::do_assem(com_mod, lM.eNoN, ptr, lK, lR);
+    lhsa_ns::do_assem_residual(com_mod, lM.eNoN, ptr, lR);
+  }
+}
+
+/// @brief Loop solid elements and assemble into global matrices
+void construct_dsolid(ComMod& com_mod, CepMod& cep_mod, 
+                      const mshType& lM, const Array<double>& Ag, 
+                      const Array<double>& Yg, const Array<double>& Dg)
 {
   using namespace consts;
 
@@ -241,17 +327,15 @@ void construct_dsolid(ComMod& com_mod, CepMod& cep_mod, const mshType& lM, const
     eval_dsolid(e, com_mod, cep_mod, lM, Ag, Yg, Dg, ptr, lR, lK);
 
     // Assemble into global residual and tangent
-    if (assembly) {
 #ifdef WITH_TRILINOS
-      if (eq.assmTLS) {
-        trilinos_doassem_(const_cast<int&>(eNoN), ptr.data(), lK.data(), lR.data());
-      } else {
+    if (eq.assmTLS) {
+      trilinos_doassem_(const_cast<int&>(eNoN), ptr.data(), lK.data(), lR.data());
+    } else {
 #endif
       lhsa_ns::do_assem(com_mod, eNoN, ptr, lK, lR);
 #ifdef WITH_TRILINOS
-     }
-#endif
     }
+#endif
   }
 }
 
diff --git a/Code/Source/svFSI/sv_struct.h b/Code/Source/svFSI/sv_struct.h
index be1e288..de97589 100644
--- a/Code/Source/svFSI/sv_struct.h
+++ b/Code/Source/svFSI/sv_struct.h
@@ -45,7 +45,13 @@ void b_struct_3d(const ComMod& com_mod, const int eNoN, const double w, const Ve
     Array<double>& lR, Array3<double>& lK);
 
 void construct_dsolid(ComMod& com_mod, CepMod& cep_mod, const mshType& lM, const Array<double>& Ag, 
-    const Array<double>& Yg, const Array<double>& Dg, const bool assembly=true);
+    const Array<double>& Yg, const Array<double>& Dg);
+
+void construct_gr(ComMod& com_mod, CepMod& cep_mod, CmMod& cm_mod, const mshType& lM, const Array<double>& Ag, 
+    const Array<double>& Yg, const Array<double>& Dg);
+
+void eval_gr(ComMod& com_mod, CepMod& cep_mod, CmMod& cm_mod, const mshType& lM, const Array<double>& Ag, 
+    const Array<double>& Yg, const Array<double>& Dg, Vector<int> &ptr, Array<double> &lR, Array3<double> &lK);
 
 void eval_dsolid(const int& e, ComMod& com_mod, CepMod& cep_mod, const mshType& lM, const Array<double>& Ag,
     const Array<double>& Yg, const Array<double>& Dg, Vector<int>& ptr, Array<double>& lR, Array3<double>& lK);
diff --git a/Code/Source/svFSI/vtk_xml.cpp b/Code/Source/svFSI/vtk_xml.cpp
index 97ba726..c242cbb 100644
--- a/Code/Source/svFSI/vtk_xml.cpp
+++ b/Code/Source/svFSI/vtk_xml.cpp
@@ -1434,14 +1434,14 @@ void write_vtus(Simulation* simulation, const Array<double>& lA, const Array<dou
   delete vtk_writer;
 }
 
-void smooth_output(Simulation* simulation)
+void smooth_output(ComMod& com_mod, CmMod& cm_mod)
 {
   using namespace consts;
 
-  auto& com_mod = simulation->com_mod;
+  // auto& com_mod = simulation->com_mod;
   auto& cm = com_mod.cm;
-  auto& cm_mod = simulation->cm_mod;
-  auto& cep_mod = simulation->cep_mod;
+  // auto& cm_mod = simulation->cm_mod;
+  // auto& cep_mod = simulation->cep_mod;
 
   const int nsd = com_mod.nsd;
   const int nEq = com_mod.nEq;
@@ -1591,7 +1591,7 @@ void smooth_output(Simulation* simulation)
     }
   }
 
-  vtk_writer->write();
+  // vtk_writer->write();
   delete vtk_writer;
 }
 
diff --git a/Code/Source/svFSI/vtk_xml.h b/Code/Source/svFSI/vtk_xml.h
index 98c7e25..9519b9c 100644
--- a/Code/Source/svFSI/vtk_xml.h
+++ b/Code/Source/svFSI/vtk_xml.h
@@ -60,7 +60,7 @@ void write_vtu_debug(ComMod& com_mod, mshType& lM, const std::string& fName);
 
 void write_vtus(Simulation* simulation, const Array<double>& lA, const Array<double>& lY, const Array<double>& lD, const bool lAve);
 
-void smooth_output(Simulation* simulation);
+void smooth_output(ComMod& com_mod, CmMod& cm_mod);
 
 };
 
